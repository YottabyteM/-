# 系统分析

## 相关概念

**系统分析：对主要因素和次要因素的分析，以及若要达到效果A，对哪些因素需要强化、哪些因素需要抑制而进行的分析称为系统分析。**

## 主流系统分析的分类

#### 1. 回归分析

#### 2. 方差分析

#### 3. 主成分分析

#####  （1）基本思想

##### 	是一种降维算法，将多个指标转化为少数几个主成分，这些主成分是原始变量的线性组合，且彼此之间互不相关，能反映出原始数据的大部分信息。

##### （2）主要步骤

1. 假设有$n$个样本，$p$个指标。可以构成大小为$n×p$ 的样本矩阵：
   $$
   x = \begin{bmatrix}   x_{11} & x_{12} & ... & x_{1p} \\   x_{21} & x_{22} & ... & x_{2p} \\ ... & ... & ... & ... \\ x_{n1} & x_{n2} & ... & x_{np} \end{bmatrix}  =(x_1,x_2...x_p)
   $$
   

2. 对样本进行标准化操作

   按列计算均值和标准差。计算得到标准化数据。
   $$
   X_{ij} = \frac{x_{ij}-\overline{x_j}}{S_j}
   $$

   $$
   X = \begin{bmatrix}   X_{11} & X_{12} & ... & X_{1p} \\   X_{21} & X_{22} & ... & X_{2p} \\ ... & ... & ... & ... \\ X_{n1} & X_{n2} & ... & X_{np} \end{bmatrix}  =(X_1,X_2...X_p)
   $$

3. 计算协方差矩阵
   $$
   R = \begin{bmatrix}   r_{11} & r_{12} & ... & r_{1p} \\   r_{21} & r_{22} & ... & r_{2p} \\ ... & ... & ... & ... \\ R_{n1} & R_{n2} & ... & R_{np} \end{bmatrix}  =(R_1,R_2...R_p)
   $$

#### 4.灰色预测

##### （1）基本思想

##### 	根据序列曲线的几何形状的相似程度来判断其联系是否紧密。曲线越接近，相应序列之间的关联度就越大，反之越小。

##### （2）其他方法相比于灰色预测的劣势：

1. 需要大量的数据，数据量少就难以找出统计规律。

2. 要求样本服从某个概率分布，要求各种因素数据与系统特征数据之间呈现线性关系且各因素间彼此无关，这都比较苛刻。
3. 计算量过大。
4. 量化和定性分析结果不相符，导致最终总结出来的规律遭到歪曲和颠倒。

##### （3）对与存在母序列的具体操作步骤

1. **画出统计图**，简单分析一下图像的性质。(没啥用)

2. **确定分析序列**。选准反映系统行为特征的序列，称为系统行为的映射量，用映射量间接表征系统行为。

   1. 母序列（参考序列、母指标）：反映系统行为特征的数据序列。
      $$
      X_0 = (X_0(1),X_0(2)...X_0(n))^{T}
      $$

   2. 子序列（比较序列、子指标）：影响系统的行为的因素组成的序列。
      $$
      X_1 = (X_1(1),X_1(2)...X_1(n))^{T}
      $$

      $$
      ...
      $$

      $$
      X_m = (X_m(1),X_m(2)...X_m(n))^{T}
      $$

3. **对变量进行预处理**(目的：去量纲、缩小变量范围简化计算)。

    1. 求出每个指标的均值。

    2. 每个元素除以均值得到结果。

4. **计算**子序列中各个指标与母序列的**关联系数**。

   ​	两极最小差为：
   $$
   a = min_i(min_k|X_0(k)-X_i(k)|)
   $$
   ​	两极最大差为：

$$
b = max_i(max_k|X_0(k)-X_i(k)|)
$$

5. 定义关联系数$\gamma$：
   $$
   \gamma\ (X_0(k),X_i(k)) = \frac{a + \rho b}{|X_0(k)-X_i(k)|+\rho b} \ \ \ \ \ \ \ \ \ \  \rho 是分辨系数，一般取0.5
   $$
   而对于两个指标$X_0$和$X_i$。只需要将序列中的每个取值进行相加求和并且取平均即可求出其灰色关联度。
   $$
   \gamma\ (X_0,X_i) = \frac{1}{n} \sum_{k = 1}^{n} \gamma\ (X_0(k),X_i(k))\ \ \ \ \ \ \ \ \
   $$

6. 比较几个灰色关联度，其中越大的表明其影响越大。

##### （4）存在母序列的代码实现

```matlab
load A.mat %处理的矩阵为A
Mean = mean(A);  % 求出每一列的均值以供后续的数据预处理
A = A ./ repmat(Mean,size(A,1),1);  %矩阵进行复制，复制为和A同等大小，然后使用点除（对应元素相除）
disp('预处理后的矩阵为：'); disp(A)
Y = A(:,1);  % 母序列
X = A(:,2:end); % 子序列
absX0_Xi = abs(X - repmat(Y,1,size(X,2)))  % 计算|X0-Xi|矩阵(在这里我们把X0定义为了Y)
a = min(min(absX0_Xi))    % 计算两级最小差a
b = max(max(absX0_Xi))  % 计算两级最大差b
rho = 0.5; % 分辨系数取0.5
gamma = (a+rho*b) ./ (absX0_Xi  + rho*b)  % 计算子序列中各个指标与母序列的关联系数
disp('子序列中各个指标的灰色关联度分别为：')
disp(mean(gamma))
```

##### （5）综合评价的操作步骤（不存在母序列的评价）

1. 对指标进行正向化。

2. 对正向化后的矩阵进行预处理得到矩阵$Z$。

3. 将预处理后的矩阵的每一行取出最大值构成母序列。

4. 计算各个指标与母序列的灰色关联度：$\gamma_1,\gamma_2....\gamma_m$。

5. 计算各个指标的权重：

   
   $$
   \omega_i = \frac{\gamma_i}{\gamma_1+\gamma_2+...+\gamma_m}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ i = 1....m
   $$

6. 第k个对象的得分为
   $$
   S_k = \sum_{i=1}^{m} Z_{ki}\omega_i
   $$

7. 对得分进行归一化，得到最终得分
   $$
   S'_i=\frac{S_i}{S_1+S_2+...S_n}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ i = 1....n
   $$

8. 根据最终得分求出结果

##### （6）不存在母序列的代码实现

```matlab
[n,m] = size(X);
disp(['共有' num2str(n) '个评价对象, ' num2str(m) '个评价指标']) 
Judge = input(['这' num2str(m) '个指标是否需要经过正向化处理，需要请输入1 ，不需要输入0：  ']);   %1
if Judge == 1
    Position = input('请输入需要正向化处理的指标所在的列，例如第2、3、6三列需要处理，那么你需要输入[2,3,6]： '); %[2,3,4]
    disp('请输入需要处理的这些列的指  标类型（1：极小型， 2：中间型， 3：区间型） ')
    Type = input('例如：第2列是极小型，第3列是区间型，第6列是中间型，就输入[1,3,2]：  '); %[2,1,3]
    % 注意，Position和Type是两个同维度的行向量
    for i = 1 : size(Position,2)  %这里需要对这些列分别处理，因此我们需要知道一共要处理的次数，即循环的次数
        X(:,Position(i)) = Positivization(X(:,Position(i)),Type(i),Position(i));
    % Positivization是我们自己定义的函数，其作用是进行正向化，其一共接收三个参数
    % 第一个参数是要正向化处理的那一列向量 X(:,Position(i))   回顾上一讲的知识，X(:,n)表示取第n列的全部元素
    % 第二个参数是对应的这一列的指标类型（1：极小型， 2：中间型， 3：区间型）
    % 第三个参数是告诉函数我们正在处理的是原始矩阵中的哪一列
    % 该函数有一个返回值，它返回正向化之后的指标，我们可以将其直接赋值给我们原始要处理的那一列向量
    end
    disp('正向化后的矩阵 X =  ')
    disp(X)
end
% =================================    （可选操作）正向化操作     ==============================================
%===========================================================================================================
%% 对正向化后的矩阵进行预处理
Mean = mean(X);  % 求出每一列的均值以供后续的数据预处理
Z = X ./ repmat(Mean,size(X,1),1);  
disp('预处理后的矩阵为：'); disp(Z)

%% 构造母序列和子序列
Y = max(Z,[],2);  % 母序列为虚拟的，用每一行的最大值构成的列向量表示母序列
X = Z; % 子序列就是预处理后的数据矩阵

%% 计算得分
absX0_Xi = abs(X - repmat(Y,1,size(X,2)))  % 计算|X0-Xi|矩阵
a = min(min(absX0_Xi))    % 计算两级最小差a
b = max(max(absX0_Xi))  % 计算两级最大差b
rho = 0.5; % 分辨系数取0.5
gamma = (a+rho*b) ./ (absX0_Xi  + rho*b)  % 计算子序列中各个指标与母序列的关联系数
weight = mean(gamma) / sum(mean(gamma));  % 利用子序列中各个指标的灰色关联度计算权重
score = sum(X .* repmat(weight,size(X,1),1),2);   % 未归一化的得分
stand_S = score / sum(score);   % 归一化后的得分
[sorted_S,index] = sort(stand_S ,'descend') % 进行排序


function [posit_x] = Positivization(x,type,i)
% 输入变量有三个：
% x：需要正向化处理的指标对应的原始列向量
% type： 指标的类型（1：极小型， 2：中间型， 3：区间型）
% i: 正在处理的是原始矩阵中的哪一列
% 输出变量posit_x表示：正向化后的列向量
    if type == 1  %极小型
        disp(['第' num2str(i) '列是极小型，正在正向化'] )
        posit_x = Min2Max(x);  %调用Min2Max函数来正向化
        disp(['第' num2str(i) '列极小型正向化处理完成'] )
        disp('~~~~~~~~~~~~~~~~~~~~分界线~~~~~~~~~~~~~~~~~~~~')
    elseif type == 2  %中间型
        disp(['第' num2str(i) '列是中间型'] )
        best = input('请输入最佳的那一个值： ');
        posit_x = Mid2Max(x,best);
        disp(['第' num2str(i) '列中间型正向化处理完成'] )
        disp('~~~~~~~~~~~~~~~~~~~~分界线~~~~~~~~~~~~~~~~~~~~')
    elseif type == 3  %区间型
        disp(['第' num2str(i) '列是区间型'] )
        a = input('请输入区间的下界： ');
        b = input('请输入区间的上界： '); 
        posit_x = Inter2Max(x,a,b);
        disp(['第' num2str(i) '列区间型正向化处理完成'] )
        disp('~~~~~~~~~~~~~~~~~~~~分界线~~~~~~~~~~~~~~~~~~~~')
    else
        disp('没有这种类型的指标，请检查Type向量中是否有除了1、2、3之外的其他值')
    end
end

function [posit_x] = Inter2Max(x,a,b)
    r_x = size(x,1);  % row of x 
    M = max([a-min(x),max(x)-b]);
    posit_x = zeros(r_x,1);   %zeros函数用法: zeros(3)  zeros(3,1)  ones(3)
    % 初始化posit_x全为0  初始化的目的是节省处理时间
    for i = 1: r_x
        if x(i) < a
           posit_x(i) = 1-(a-x(i))/M;
        elseif x(i) > b
           posit_x(i) = 1-(x(i)-b)/M;
        else
           posit_x(i) = 1;
        end
    end
end

function [posit_x] = Min2Max(x)
    posit_x = max(x) - x;
     %posit_x = 1 ./ x;    %如果x全部都大于0，也可以这样正向化
end

function [posit_x] = Mid2Max(x,best)
    M = max(abs(x-best));
    posit_x = 1 - abs(x-best) / M;
end
```

